:proglang: Motoko
= {proglang} Programming Language Guide

This document is a book that describes {proglang}, a
programming language for
the <<internet-computer, Internet Computer>>,
and more.

== Chapter: Introduction

IMPORTANT: All sections in this chapter are ready for review.

{proglang} is a modern language designed to be approachable for
programmers who have some basic familiarity with modern
object-oriented and/or functional programming idioms in either
JavaScript, or another modern programming language, such as Rust,
Swift, TypeScript, C# or Java.

{proglang} permits modern programming idioms, including special
programming abstractions for distributed applications.  Each
application consists of an _actor_ that communicates with other actors
_without_ using shared state, but instead by using (asynchronous)
message passing.
The <<pitch-actors,actor-based>>
<<pitch-async-actors,programming abstractions>> of
{proglang} permit human-readable message-passing patterns,
and they enforce that each network interaction obeys certain rules and
avoids certain common mistakes.

Specifically, {proglang} programs are _type sound_ since {proglang}
includes a practical, <<pitch-types,modern type system>> that checks each one before
it executes.  The {proglang} type system statically checks that each
{proglang} program will execute safely, without internal type errors,
on all possible inputs.  Consequently, entire classes of common
programming pitfalls that are common in other languages are ruled out,
including null pointer errors, mis-matched argument and result types
and many others.

To execute, {proglang} statically compiles to <<wasm, WebAssembly>>, a
portable binary format that abstracts cleanly over modern computer
hardware, and thus permits its execution broadly on the Internet, and
the <<internet-computer, Internet Computer>>.

[[pitch-actors]]
=== Each microservice as an _actor_

{proglang} provides an *actor-based* programming model to developers
to express _server behavior_, including that of _micro services_ on the
Internet and the <<internet-computer, Internet Computer>>.

An actor is similar to an object, but is special in that its
isolated state exists _remotely_, and its interactions with the world
are _asynchronous_.

All communication with and between actors involves passing messages
asynchronously over the network using the Internet Computer's
messaging protocol.  An actorâ€™s messages are processed in sequence, so
state modifications never cause race conditions.

The underlying computing platform provided by the Internet Computer
ensures that each message-based synchronization will reach
a close, but in doing so each one may also fail due to the usual
reasons that arise in distributed systems, including time out.

[[pitch-async-actors]]
=== Asynchronous actors

Like other _modern_ programming languages, {proglang} permits an ergonomic syntax
for _asynchronous_ communication among components.

In the case of {proglang}, each communicating component is an actor.

As an example of _using_ actors, perhaps as an actor ourselves,
consider this three-line program:

....
let result1 = service1.computeAnswer(params);
let result2 = service2.computeAnswer(params);
finalStep(await result1, await result2)
....

We can summarize the program's behavior with three steps:

* i. First, the program makes two requests (lines 1 and 2), to two
distinct services, each implemented internally as an actor (object).

* ii. Next, on line 3, the program waits for these two results to each
be ready, using the keyword `await` on each result value.

* ii. Finally, on line 3, when both results are available, the program
uses them in the final step, calling the function `finalStep`.

Generally speaking, the services _interleave_ their executions rather
than wait for one another, since doing so reduces overall latency.
However, if we try to reduce latency this way _without_ special
language support, such interleaving will quickly sacrifice clarity and
simplicity.

Even in cases where there are _no_ interleaving executions (for example, if there were only one call above, not two),
the programming abstractions still permit clarity and simplicity,
for the same reason.
Namely, they signal to the compiler where to transform the program, freeing the programmer from contorting the program's logic in order to interleave
its execution with the underlying system's message-passing loop.


Here, the program uses `await` in step ii (line 3) to express that
interleaving behavior in a simple fashion, with human-readable syntax
that is provided by {proglang}.

In language settings that lack these abstractions, developers would
not merely call these two functions directly, but would instead employ
very advanced programming patterns, possibly registering
developer-provided "`callback functions`" within system-provided "`event
handlers`".  Each callback would handle an asynchronous event that
arises when an answer is ready.  This kind of systems-level
programming is powerful, but very error-prone, since it decomposes a
high-level data flow into low-level system events that communicate
through shared state.  Sometimes this style is necessary, but here it
is not.

Our program instead eschews that (cumbersome, indirect) programming
style for this more natural, _direct_ style, where each request
resembles an ordinary function call.  This simpler, stylized
programming form has become increasingly popular for expressing
practical systems that interact with an _external environment_, as
most modern software does today.  However, it requires special
compiler and type-system support, as we discuss in more detail below.

[[pitch-async-behavior]]
==== Support for _asynchronous_ behavior

In an _asynchronous_ computing setting, a program and its running
environment are permitted to perform _internal computations_ that
occur _concurrently_ with one another.

Specifically, asynchronous programs are ones where the program's
requests of its environment do not (necessarily) require the program
to wait for the environment. In the meantime, the program is permitted
to make internal progress within this environment while it waits,
perhaps _actively_. In the example, above, the program makes the
second request while still waiting for the first micro service.

Symmetrically, the environment's requests of the program do not
(necessarily) require the environment to wait for the program's answer
to make external progress around it while it waits for this answer.

We do not show an example of this "`notify`" pattern above, since it
uses callbacks (and _higher-order_ functions and control flow) and is
thus more complex.  However, we discuss <<example-notify,a detailed example>> later in this text.

[[pitch-async]]
==== Syntactic forms `async` and `await`

To address the need for clarity and simplicity, {proglang} adopts the
increasingly-common program constructs `async` and `await`, which
afford the programmer a _structured_ language for describing
potentially-complex asynchronous dependency graphs.

The <<exp-async,syntax `async`>> introduces the _"`promise`" of asynchronous data in
the future_ (not shown in the first example above).  We discuss the introduction of asynchronous promises when we
<<chapter-actors,introduce actors>>.

Here, we merely use the ones that
arise from calling `service1.computeAnswer(params)` and
`service2.computeAnswer(params)`.

The syntax `await` synchronizes on a previously-made promise, and
potentially blocks until the future when this promise is fulfilled by
its producer.  We show two uses of the `await` form in the example
above, which await the results of the two services.

When the developer uses these keywords, the compiler transforms the
program as necessary, often doing complex transformations to the
program's control- and data-flow that would be tedious to perform by
hand.  Meanwhile, the type system of {proglang} enforces certain
correct usage patterns for these constructs, including that types
flowing between consumers and producers always agree, and that the
types of data sent among services are permitted to flow there, and do
not (for example) contain <<chapter-state,private mutable state>>.

[[pitch-types]]
=== Types are static

Like other modern programming languages, {proglang} permits each
variable to carry the value of a function, object, or a primitive
datum (e.g., a string, word or integer).  Other <<intro-values,
types of values exist too>>, including records, tuples, and "`tagged
data`" called _variants_.

{proglang} enjoys the formal property of type safety, also known as
_type soundness_.  We often summarize this idea with the phrase:
<<intro-type-soundness,"`Well-typed {proglang} programs don't go wrong`">>, meaning here that
they do not misuse program constructs by treating them as if they have
the wrong type.

For example, each variable in a {proglang} program carries an
associated _type_, and this type is known _statically_, before the
program executes.  Each use of each variable is checked by the
compiler to prevent runtime type errors, including null pointer
errors.

In this sense, {proglang} types provide a form of _trusted
(**compiler-verified**) documentation_ in the program source code.

As usual, dynamic testing can check properties that are beyond the
reach of the {proglang} type system.  While modern, the {proglang}
type system is intentionally _not_ "`advanced`" or exotic in any new ways.
Rather, the type system of {proglang} integrates lessons from modern, but
well-understood, <<modern-types,practical type systems>> of today to provide an approachable,
yet _mathematically precise_ language for general-purpose, distributed programming.

=== {proglang} engineering values

The design and initial implementation of {proglang} each represent
established, but _ongoing_ language engineering efforts.

To guide these efforts, we establish the following sets of _engineering
values_, which identify and distinguish our core values from our secondary
values, and each of these sets of values from the non-values and
non-goals of our efforts on {proglang}.

==== Core values & goals (in order):

1. Seamless integration with the <<internet-computer, platform>> (actors, messaging, persistence, IDL interoperability, ...)
2. Ergonomics (familiarity, simplicity, clarity, explicitness, persistence, ...)
3. Correctness (state isolation, sound type system, safety, bignums, pattern matching, "good" defaults/no footguns, ...)

==== Secondary values & goals ("`nice to have`"):

1. Expressiveness, including first-class functions, polymorphism, and pattern matching.  (We have each of these already, but more could follow.)
2. Performance (probably not great, _yet_.)
3. Batteries included (libraries, SDK, examples, etc.)

==== Non-Values & non-goals ("`Things we are not focusing on`"):

1. Having a more advanced type system, with more complex types
2. "`Worse is Better`"
3. Interoperability with existing smart contract platforms


=== Reading this guide

Above, we summarize the core design considerations of {proglang}.

Below, we connect these considerations to code examples, starting with
the most fundamental concepts first, including the role of types and
type annotations in very small programs.

Then, we ramp up quickly to programs that compute in more interesting
ways, including function abstractions, user-defined type definitions,
user-defined actors, the standard library of collections, and
asynchronous communication.

This document is meant to guide readers from many backgrounds through
the (evolving) design of {proglang}.  Yet this document, and the
language implementation are each evolving quickly themselves.


=== Sign posts used in this text

We use "`sign posts`" to communicate to readers and editors.

This section gives a lists of these sign posts, including their intended audience and meaning.

---

We will identify sections and chapters where content is ready for
review and copyediting as "`IMPORTANT`" sign post.  For example:

IMPORTANT: Sections X, Y and Z below are ready.

IMPORTANT: All sections in this chapter are ready.

---

We will identify places where content is missing using the following sign "`CAUTION`" post:

CAUTION: Topic X is missing here

---

We will identify places where content is outdated or stale using the "`WARNING`" sign post:

WARNING: Topic X needs to be revised to adhere to concepts A, B and C

---

We will identify places where content describes future features using the "`NOTE`" sign post:

NOTE: Feature X is not yet supported by the platform, but is planned for the future.

---


== Chapter: Basic concepts and terms

IMPORTANT: All sections in this chapter are ready.

{proglang} is designed for distributed programming with actors.

Before considering that ultimate purpose, we first consider the basic
building blocks of the language, in so doing, introduce concepts and
terms that we use throughout the remainder of this book.

In particular, we introduce terms _program_, _declaration_,
_expression_, _value_, _variable_, and _type_.

The use of these terms in {proglang} should be unsurprising to anyone
familiar with <<modern-types,modern programming language theory>>.  For other readers,
we introduce these terms gradually, by initially using tiny example
programs that eschew any use of actors or distributed programming.
After establishing basic terminology, we introduce those more advanced
aspects of the language, illustrated with larger examples.

While defining terms, we also review related concepts and keywords:

 - <<intro-progs,Program syntax>>, and <<intro-full-syntax,full syntax overview>>
 - <<intro-printing,Printing numbers and text>>, and <<intro-stdlib, using the standard library>>
 - <<intro-decls-vs-exps,Declarations versus expressions>>
 - <<intro-lexical-scoping,Lexical scoping of variables>>
 - <<intro-values,Values and evaluation>>
 - <<intro-type-anno,Type annotations variables>>
 - <<intro-type-soundness,Type soundness and type-safe evaluation>>

[[intro-progs]]
=== {proglang} programs

Each {proglang} _program_ is a free mix of declarations and
expressions, whose syntactic classes are distinct,
but related (see <<syntax, the appendix>> for precise program syntax).

For programs that we deploy on the Internet Computer,
a valid program consists of an __actor expression__,
introduced with specific syntax (keyword `actor`) that we discuss in
a <<chapter-actors,later chapter>>.

In preparing for that discussion, we discuss programs in this chapter
and <<chapter-state,the next>> that are not meant to be Internet Computer services.
Rather, these tiny programs illustrate snippets of {proglang} for writing
those services, and each can (usually) be run on its own as a (non-service)
{proglang} program, possibly with some printed terminal output.

We begin with simple expressions, such as arithmetic.
We encourage advanced readers to skip around, and to use <<intro-full-syntax,this
chart>> for a quick overview of the full (expression) syntax of
{proglang}, with additional links and detailed definitions.

For other readers, we start slowly and move gradually.  The following
snippet consists of two declarations (of variables `x` and `y`)
followed by an expression, forming a single program:

....
let x = 1;
let y = x + 1;
x * y + x
....

We will use variations of this small program in our discussion below.

First, this program's type is `Nat` (natural number), and when run, it
evaluates to the (natural number) value of `3`.


Introducing a block with enclosing braces (`{` and `}`) and another
variable (`z`), we can amend our original program as follows:

....
let z = {
  let x = 1;
  let y = x + 1;
  x * y + x
};
printNat(z)
....


Before comparing declaration lists and expressions in more detail, we
briefly digress to explain the `printNat` primitive, used in the final
line above.

[[intro-printing]]
=== Printing via `print` and `debug_show`

Above, we print the final value using the built-in function
`printNat`:

....
printNat: Nat -> ()
....

The function `printNat` accepts a natural number value (of type `Nat`)
as input, and produces the _unit value_ (of _unit type_, or `()`) as
its output.

In a sense, there is no output.  The function `printNat` is impure,
and rather than producing an output value, it produces the _effect_ of
emitting the natural number in a human-readable form to the output
terminal.  We discuss the return value (the unit value) <<intro-unit-type, in detail
below>>, and relate it to the `void` type for readers more familiar with
that concept.

Likewise, we can print text strings using `print`:

....
print: Text -> ()
....

So that the following program prints "hello world":

....
print("hello world")
....

Finally, we can transform most {proglang} values into human-readable
text strings for debugging purposes, _without_ having to write those
transformations by hand.

The `debug_show` primitive permits converting a large class of values into values of type `Text`.

For instance, we can convert a triple (of type `(Text, Nat, Text)`) into debugging
text without writing a custom conversion function ourselves:

....
print(debug_show(("hello", 42, "world")))
....

Using these text transformations, we can print most {proglang} data as
we experiment with our programs.

=== Declarations and expressions

Declarations introduce immutable variables, mutable state, actors,
objects, classes and other types.
Expressions describe computations that involve these notions.

For now, we use example programs that declare immutable variables,
and compute simple arithmetic.

[[intro-decls-vs-exps]]
==== Declarations versus expressions

<<intro-progs,Recall>> that
each {proglang} _program_ is a free mix of declarations and
expressions, whose syntactic classes are distinct,
but related.  In this section,
we use examples to illustrate their distinctions
and accommodate their intermixing.


Recall our example program, first introduced above:

....
let x = 1;
let y = x + 1;
x * y + x;
....

In reality, this program is a _declaration list_ that consists of _three_ declarations:

. immutable variable `x`, via declaration `let x = 1;`,
. immutable variable `y`, via declaration `let y = x + 1;`,
. and an _unnamed, implicit variable_ holding the final expression's value, `x * y + x`.

This expression `x * y + x` illustrates a more general principle:
//
Each expression can be thought of as a declaration where necessary
since the language implicitly declares an unnamed variable with that expression's
result value.

When the expression appears as the final declaration, this expression may have any type.  Here, the expression `x * y + x` has type `Nat`.

Expressions that do not appear at the end, but rather _within_ the list of declarations must have unit type, as with printing:

....
let x = 1;
printNat(x);
let y = x + 1;
printNat(y);
x * y + x;
....

==== Use `ignore` to place non-unit-typed expressions in declaration lists

We can always overcome this unit-type restriction by explicitly using `ignore` to ignore any unused result values:

....
let x = 1;
ignore(x + 42);
let y = x + 1;
ignore(y * 42);
x * y + x;
....

==== Declarations and variable substitution

Declarations may be mutually recursive, but in cases where they are
not, they permit a substitution semantics.

Recall our original example:
....
let x = 1;
let y = x + 1;
x * y + x;
....

We may manually rewrite the program above by _substituting_ the
variables' declared values for each of their respective occurrences.

In so doing, we produce the following expression, which is also a program:

....
1 * (1 + 1) + 1
....

This is also a valid program, of the same type and with the same
behavior (result value) as the original program, `3`.

We can also form a single expression using a block.

==== From declarations to block expressions

Many of the programs above each consist of a list of declarations, as
with this example, just above:

....
let x = 1;
let y = x + 1;
x * y + x
....

A declaration list is not itself (immediately) an _expression_, so we
cannot (immediately) declare another variable with its final value
(`3`).

[[intro-exp-block]]
**Block expressions.** We can form a _block expression_ from
this list of declarations by enclosing it with matching _curly braces_:

....
{
  let x = 1;
  let y = x + 1;
  x * y + x
}
....

This is also program, but one where the declared variables `x` and `y`
are privately scoped to the block we introduced.

This block form preserves the autonomy of the declaration list
and its _choice of variable names_.

[[intro-lexical-scoping]]
==== Declarations follow *lexical scoping*

Above, we saw that nesting blocks preserves the autonomy of each separate declaration list
and its _choice of variable names_.  Language theorists call this idea _lexical scoping_.  It means
that variables' scopes may nest, but they may not interfere as they nest.

For instance, the following (larger, enclosing) program evaluates to
`42`, _not_ `2`, since the final occurrences of `x` and `y`, on the
final line, refer to the _very first_ definitions, _not_ the later
ones within the enclosed block:

....
let x = 40; let y = 2;
{
  let x = 1;
  let y = x + 1;
  x * y + x
};
x + y
....

Other languages that lack lexical scoping may give a different meaning
to this program.  However, modern languages universally favor
lexical scoping, the meaning given here.

Aside from mathematical clarity, the chief practical benefit of
lexical scoping is _security_, and its use in building
compositionally-secure systems.  Specifically, {proglang} gives very
strong composition properties: Nesting your program within one you do
not trust cannot, for example, arbitrarily reassociate your variable
occurrences with different meanings.

[[intro-values]]
=== Values and evaluation

Once a {proglang} expression receives the program's (single) thread of
control, it evaluates eagerly until it reduces to a _(result) value_.

In so doing, it will generally pass control to sub-expressions, and to
sub-routines before it gives up control from the _ambient control
stack_.

If this expression never reaches a value form, the expression
evaluates indefinitely.  Later we introduce recursive functions and
imperative control flow, which each permit non-termination.  For now,
we only consider terminating programs that result in values.

In the material above, we focused on expressions that produced natural
numbers.  As a broader language overview, however, we briefly
summarize the other value forms below:

==== Primitive values

{proglang} permits the following primitive value forms:

 - Boolean values (`true` and `false`).
 - Integers (...,`-2`, `-1`, `0`, `1`, `2`, ...); Bounded and _unbounded_ variants.
 - Natural numbers (`0`, `1`, `2`, ...); Bounded and _unbounded_ variants.
 - Text values --- strings of unicode characters.
 - Words --- fixed-width numbers, _without_ overflow checks, and _with_ explicit wrap-around semantics.

*Numbers.* By default, integers and natural numbers are _unbounded_ and do not overflow.  Instead,
they use representations that grow to accommodate any finite number.

For practical reasons, {proglang} also includes _bounded_ types for
integers and natural numbers, distinct from the default versions.
Each bounded variant has a fixed width (one of `8`, `16`, `32`,
`64`) and each carries the potential for "`overflow`". If and when
this event occurs, it is an error and causes the
<<overview-traps,program to trap>>.  There are no unchecked, uncaught
overflows in {proglang}, except in well-defined situations, for specific (`Word`-based) types.

Word types permit bitwise operations that are unsupported by the other
number types.  The language provides <<compiler-prelude-convert,primitive builtins to
inter-convert between these various number representations>>.

The appendix contains a complete list of <<primitive-types,primitive types>>.

==== Non-primitive values

Building on the primitive values and types above, the language permits
user-defined types, and each of the following non-primitive value
forms and associated types:

 - <<tuples,Tuples>>, including the unit value (the "empty tuple")
 - <<exp-arrays, Arrays>>, with both _immutable_ and _mutable_ variants.
 - <<exp-object,Objects>>, with named, unordered fields and methods
 - <<variant-types,Variants>>, with named constructors and optional payload values
 - <<exp-func,Function values>>, including <<sharability,shareable functions>>.
 - <<exp-async,`async` values>>, also known as _promises_ or _futures_.
 - <<exp-error, `Error` values>> carry the payload of exceptions and system failures

We discuss the use of these forms in the succeeding chapters.

The links above give precise language definitions from the appendix.

[[intro-unit-type]]
==== The *unit type* versus the `void` type

{proglang} has no type named `void`.  In many cases where readers may
think of return types being "`void`" from using languages like Java or
C++, we encourage them to think instead of the _unit type_, written `()`.

In practical terms, like `void`, the unit value usually carries zero
representation cost.

Unlike the `void` type, there _is_ a unit value, but like the `void`
return value, the unit value carries no values internally, and as
such, it always carries zero _information_.

Another mathematical way to think of the unit value is as a tuple with
no elements---the nullary ("`zero-ary`") tuple. There is only one value with these
properties, so it is mathematically unique, and thus need not be
represented at runtime.


==== Natural numbers

The members of this type consist of the usual values ---`0`, `1`, `2`,
...----but, as in mathematics, the members of are not bound to a
special maximum size.  Rather, the (runtime) representation of these
values accommodates arbitrary-sized numbers, making their "overflow"
(nearly) impossible. (_nearly_ because it is the same event as running
out of program memory, which can always happen for some programs in
extreme situations).

{proglang} permits the usual arithmetic operations one would expect.
As an illustrative example, consider the following program:

....
let x = 42 + (1 * 37) / 12: Nat
....

This program evaluates to the value `45`, also of type `Nat`.

[[intro-type-soundness]]
=== Type soundness

Each {proglang} expression that type-checks we call _well-typed_.  The
_type_ of a {proglang} expression serves as a promise from the language to
the developer about the future behavior of the program, if executed.

First, each well-typed program will evaluate without undefined
behavior.  That is, the phrase **"`well-typed programs don't go wrong`"**
applies here.  For those unfamiliar with the deeper implications of
that phrase, it means that there is a precise space of meaningful
(unambiguous) programs, and the type system enforces that we stay
within it, and that all well-typed programs have a precise
(unambiguous) meaning.

Furthermore, the types make a precise prediction over the program's
result. If it yields control, the program will generate a _(result)
value_ that agrees with that of the original program.

In either case, the static and dynamic views of the program
are linked by and agree with the static type system.
This agreement is the central principle of a static type system, and
is delivered by {proglang} as a core aspect of its design.

The same type system also enforces that asynchrononous interactions
agree between static and dynamic views of the program, and that the
resulting messages generated "under the hood" never mismatch at run
time.  This agreement is similar in spirit to the caller/callee
argument type and return type agreements that one ordinarily expects in a
typed language.

[[intro-type-anno]]
=== Type annotations and variables

Variables relate (static) names and (static) types with (dynamic)
values that are present only at runtime.

In this sense, {proglang} types provide
a form of _trusted, compiler-verified documentation_
in the program source code.

Consider this very short program:

....
let x : Nat = 1
....

In this example, the compiler infers that the expression `1` has
type `Nat`, and that `x` has the same type.

In this case, we can omit this annotation without changing the meaning
of the program:

....
let x = 1
....

Except for some esoteric situations involving operator overloading,
type annotations do not (typically) affect the meaning
of the program as it runs.

If they are omitted and the compiler accepts the program, as is the
case above, the program has the same meaning (same _behavior_) as it
did originally.

However, sometimes type annotations are required by the compiler to
infer other assumptions, and to check the program as a whole.

When they are added and the compiler still accepts the program, we know
that the added annotations are _consistent_ with the existing ones.

For instance, we can add additional (not required) annotations, and
the compiler checks that all annotations and other inferred facts
agree as a whole:

....
let x : Nat = 1 : Nat
....

If we were to try to do something _inconsistent_ with our annotation
type, however, the type checker will signal an error.

Consider this program, which is not well-typed:

....
let x : Text = 1 + 1
....

The type annotation `Text` does not agree with the rest of the
program, since the type of `1 + 1` is `Nat` and not `Text`, and these
types are unrelated by subtyping.  Consequently, this program is not
well-typed, and the compiler will signal an error (with a message and
location) and will not compile or execute it.


=== Type errors and messages

Mathematically, the type system of {proglang} is _declarative_,
meaning that it exists independently of any implementation, as a
concept entirely in formal logic.  Likewise, the other key aspects of
the language definition (e.g., its execution semantics) exist outside
of an implementation.

However, to design this logical definition, to experiment with it, and
to practice making mistakes, we want to interact with this type
system, and to make lots of harmless mistakes along the way.

The error messages of the _type checker_ attempt to help the developer
when they misunderstand or otherwise misapply the logic of the type
system, which is explained indirectly in this book.

These error messages will evolve over time, and for this reason, we
will not include particular error messages in this text.  Instead, we
will attempt to explain each code example in its surrounding prose.


[[intro-stdlib]]
=== Using the {proglang} standard library

For various practical language engineering reasons,
the design of {proglang} strives to minimize builtin types and operations.

Instead, whenever possible, the {proglang} standard library
provides the types and operations that make the language feel complete.
__**However**, this standard library is still under development,
and is still incomplete__.

An <<appendix-stdlib, appendix chapter>> lists a _selection_ of
modules from the {proglang} standard library, focusing on core
features used in the examples that are unlikely to change radically.
However, all of these standard library APIs will certainly change over
time (to varying degrees), and in particular, they will grow in size
and number.

To import from the standard library, use the `import` keyword.  Give a
local module name to introduce, in this example `P` for
"`**P**relude`", and a URL where the `import` declaration may locate
the imported module:

....
import P "mo:stdlib/Prelude";
P.printLn("hello world");
....

In this case, we import {proglang} code (not some other module form)
with the `mo:` prefix.  We specify the `stdlib/` path, followed by the
module's file name `prelude.mo` minus its extension.

=== Accommodating incomplete code

Sometimes, in the midst of writing a program, we want to run an
incomplete version, or a version where one or more execution paths are
either missing or simply invalid.

To accommodate these situations, we use the `xxx`, `nyi` and
`unreachable` functions from the standard library, explained below.
Each wraps a <<overview-traps,general trap mechanism>>,
explained further below.


==== Use short-term holes

Short-term holes are never committed to a source repository, and only
ever exist in a single development session, for a developer that is
still writing the program.

Assuming that earlier, one has imported the prelude as follows:

....
import P "mo:stdlib/Prelude";
....

The developer can fill _any missing expression_ with the following one:

....
P.xxx()
....

The result will _always_ type check at compile time, and _will always_
trap at run time, if and when this expression ever executes.

===== Document longer-term holes

By convention, longer-term holes can be considered "yet not
implemented" (`nyi`) features, and marked as such with a similar
function from the prelude:

....
P.nyi()
....


===== Document `unreachable` code paths

In contrast to the situations above, sometimes code will _never_ be
filled, since it will _never_ be evaluated, assuming the coherence of
the internal logic of the programs' invariants.

To document a code path as logically impossible, or _unreachable_, use
the standard library function `unreachable`:

....
P.unreachable()
....

As in the situations above, this function type-checks in all contexts,
and when evaluated, traps in all contexts.


[[overview-traps]]
==== Execution traps stop the program

Each form above is a simple wrapper around the always-fail use of the
<<exp-assert, `assert` primitive>>:

....
assert false
....

Dynamically, we call this program-halting behavior a
_program(-generated) trap_, and we say that the program _traps_ when
it executes this code.  It will cease to progress further.



== Chapter: Local objects and classes

In addition to (remote) actor objects, {proglang} provides local
objects that are similar in their syntax, typing and evaluation to
ordinary (local) objects from object-oriented programming.

The <<chapter-state, prior chapter>> introduced declarations of
private mutable state, in the form of `var`-bound variables and
(mutable) array allocation.  In this chapter, we use mutable state to
implement simple objects, a la object-oriented programming.

We illustrate this support via a running example, which continues in
the <<chapter-actors,following chapter>>.  This example illustrates
a general evolution path for {proglang} programs: Each
_object_, if important enough, has the potential to be refactored into
an Internet _service_, by refactoring this _(local) object_ into an _actor object_.


=== Example: The `counter` object

Consider the following _object declaration_
of the object value `counter`:
....
object counter = {
  var count = 0;
  public func inc() { count += 1 };
  public func read() : Nat { count };
  public func bump() : Nat {
    inc();
    read()
  };
};
....

This declaration introduces a single object instance named `counter`,
whose entire implementation is given above.

In this example, the developer exposes three _public_ functions `inc`,
`read` and `bump` using keyword `public` to declare each in the object
body.  The body of the object, like a <<intro-exp-block,block
expression >>, consists of a list of declarations.

In addition to these three functions, the object has one (private)
mutable variable `count`, which holds the current count, initially
zero.

=== Object types

This object `counter` has the following _object type_ type, written as
a list of field-type pairs, enclosed in braces (`{` and `}`):

....
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
....

Each field type consists of an identifier, a colon `:`, and a type for
the field content.  Here, each field is a function, and thus has an
_arrow_ type form (`_ -> _`).

In the declaration of `object`, the variable `count` was
explicitly declared neither as `public` nor as `private`.

By default, all declarations in an object block are `private`, as is
`count` here.  Consequently, the type for `count` does not appear in
the type of the object, _and_ its name and presence are both
inaccessible from the outside.

The inaccessibility of this field comes with a powerful benefit: By
not exposing this implementation detail, the object has a _more
general_ type (fewer fields), and as a result, is interchangeable with
objects that implement the same counter object type differently,
without using such a field.

=== Example: The `byte_counter` object

To illustrate the point just above, consider this variation of the
`counter` declaration above, of `byte_counter`:

....
object byte_counter = {
  var count : Nat8 = 0;
  public func inc() { count += 1 };
  public func read() : Nat { nat8ToNat(count) };
  public func bump() : Nat { inc(); read() };
};
....

This object has the same type as the previous one, and thus from the
standpoint of type checking, this object is interchangeable with the
prior one:

....
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
....

Unlike the first version, however, this version does not use the same
implementation of the counter field.  Rather than use an ordinary
natural `Nat` that never overflows, but may also grow without bound,
this version uses a byte-sized natural number (type `Nat8`) whose size
is always eight bits.

As such, the `inc` operation may fail with an overflow for this
object, but never the prior one, which may instead (eventually) fill
the program's memory, a different kind of application failure.

Neither implementation of a counter comes without some complexity, but
in this case, they share a common type.

In general, a common type shared among two implementations (of an
object or service) affords the potential for the internal
implementation complexity to be factored away from the rest of the
application that uses it.  Here, the common type abstracts over the
simple choice of a number's representation.  In general, the
implementation choices would each be more complex, and more
interesting.

=== Object subtyping

To illustrate the role and use of object subtyping in {proglang},
consider implementing a simpler counter with a more general type
(fewer public operations):

....
object bump_counter = {
  var c = 0; public func bump() : Nat { c += 1; c };
};
....

The object `bump_counter` has the following object type, exposing
exactly one operation, `bump`:

....
{ bump : () -> Nat }
....

This type exposes the most common operation, and one that only permits
certain behavior.  For instance, the counter can only ever increase,
and can never decrease or be set to an arbitrary value.

In other parts of a system, we may in fact implement and use a _less
general_ version, with _more_ operations:

....
full_counter : {
  inc   : () -> () ;
  read  : () -> Nat ;
  bump  : () -> Nat ;
  write : Nat -> () ;
}
....

Here, we consider a counter named `full_counter` with a less general
type than any given above.  In addition to `inc`, `read` and `bump`,
it additionally includes `write`, which permits the caller
to change the current count value to an arbitrary one, such as back to `0`.

**Object subtyping.** In {proglang}, objects have types that may
  relate by subtyping, as the various types of counters do above.  As
  is standard, types with _more fields_ are _less general_ (are _**sub**types_
  of) types with _fewer fields_.  For instance, we can summarize the
  types given in the examples above as being related in the following
  subtyping order:

- Most general:

....
{ bump : () -> Nat }
....

- Middle generality:

....
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
}
....

- Least generality:

....
{
  inc  : () -> () ;
  read : () -> Nat ;
  bump : () -> Nat ;
  write : Nat -> () ;
}
....

If a function expects to receive an object of the first type (`{ bump
: () -> Nat }`), _any_ of the types given above will suffice, since
they are each equal to, or a subtype of, this (most general) type.

However, if a function expects to receive an object of the last,
least general type, the other two will _not_ suffice, since they each
lack the needed `write` operation, to which this function rightfully
expects to have access.

TIP: As aside for language theorists and advanced readers:
Object subtyping in {proglang} uses _structural subtyping_,
not _nominal subtyping_.  Recall that in nominal typing, the question of two types equality depends on choosing consistent, globally-unique type names (across projects and time).
In {proglang}, the question of two types' equality is based on their _structure_, not their names.

**Subtyping in general.** Formally, <<subtyping, subtyping relationships in {proglang}>> extend
  to all types, not just object types.  Most cases are standard, and
  follow <<modern-types, conventional programming language theory>> (for _structural_ subtyping, specifically).
  Other notable cases in {proglang} for new programmers include
  <<intro-array-subtyping, arrays>>,
  <<exp-error, options>>, <<chapter-patterns, variants>> and
  <<subtyping, number type inter-relationships>>.


=== Object classes

CAUTION: to do: examples and prose here


[[chapter-actors]]
== Chapter: Actors and `async` data

Each {proglang} actor represents a service that one might want to
deploy on the <<internet-computer, Internet Computer>>.

The interface of each actor introduces `async` data whenever it
returns information to its caller.  This programming abstraction
serves a key role in {proglang}, as it coordinates with the
transformations of the {proglang} compiler pipeline and eventual
execution behavior of {proglang} actors on the Internet Computer.

This abstraction represents a _promise_ from the system to the caller,
on behalf of the callee:

 - Either the `async` value, when ``await``ed,
will yield a value from the callee of the expected type,

 - or, an error --- system-level or callee-level --- will eventually arise.

In general, the caller may not _immediately_ `await` each call.  But
even in cases when they do, they use the same `async` and `await`
abstractions, for the same reason: To maintain the illusion of
call-return, direct-style control flow, as supported by the {proglang}
compiler's transformations.

*Technical aside.* In reality, the underlying message-passing of the
system forces the program's logic into another form.  Specifically,
control flow around each actor method call involves the program
loosing control to a system-level message-processing loop, which
forces the program's logic into a so-called
_"continuation-passing-style"_ (CPS) to expose event-handling
_"callback functions"_.  This program structure is complex for humans
to read and maintain, and stands in stark contrast to the direct style
most prefer for most program logic.

We note that {proglang} programs may avoid callbacks for many cases,
but not _all_ cases where they are used in other asynchronous,
message-passing settings.  Notably, callbacks are still needed when
they serve as a fundamental aspect of the service's interface, as with
a <<example-notify,notification service>>, where users register with
the service to get notified some times later, when some predetermined
class of events, occur over time.

'''

To start, we consider the simplest stateful service: A counter with
a single "current count" value.

=== Example: a Counter service

Consider the following actor object (a value form):

....
actor Counter {
  var count : Nat = 0;

  public func increment() : async () {
    count += 1;
  };

  public query func get_current() : async Nat {
    count
  };

  public func set_current(n: Nat) : async () {
    count := n;
  };
}
....

CAUTION: todo: discuss counter example

=== Using `async` values by ``await``-ing their answer values

To get the underlying content of an `async` value, such as a return
value from `get_current` above, the caller uses `await`:

....
let a : async Nat = counter.get_current()
let c : Nat = await(counter.get_current())
....

The first line gets _a promise of the current value_ (the variable `a`),
but does not wait for it, and thus cannot use it as a natural number.

The second line immediately inspects this promise and gets the natural
number, or waits until it is ready.

NOTE: For now, the {proglang} compiler gives an error for calls that
do not follow this second form, which is currently required to ensure
that certain program resources will always be reclaimed.


=== Actor classes generalize an actor's initial state

An actor class defines a constructor function that produces objects of
a predetermined type, with a predetermined interface and behavior.

For example, we can generalize `Counter` given above to `CounterInit`
below, by introducing a constructor parameter, variable `init` of type
`Nat`:

....
actor class CounterInit(init: Nat) {
  var count : Nat = init;

  public func increment() : async () {
    count += 1;
  };

  public query func get_current() : async Nat {
    count
  };

  public func set_current(n: Nat) : async () {
    count := n;
  };
}
....

To use this class, we can create several actors with different initial
values:

....
let c1 = CounterInit(1);
let c2 = CounterInit(2);
....

The two lines above _instantiate_ the actor class twice, once per
line.  The first invocation uses the initial value `1`, where the
second uses initial value `2`.  Their interface is common, and in
terms of their types, they are compatible and can be used
interchangeably.

NOTE: For now, the {proglang} compiler gives an error when compiling
programs that do not consist of a single actor.  The interpreter
accommodates the examples above.


[[exp-error]]
== Chapter: Errors and optional results

CAUTION: Not complete

to do:

 - ground the concepts: Errors as return values versus errors via special, exceptional control flow
 - this chapter introduces special uses of `switch` and `try` constructs
 - `switch` supports general pattern-matching;
   point to broader discussion of `switch` and <<chapter-patterns, pattern matching (next chapter)>>
 - handle errors as values with `switch` (not with `try`)
 - design question in an API: When to use which?
 - handle errors as exceptions with `try` --- in a way, these are less general for API design; may only appear in certain (`async`) contexts.  But they can recover from errors that would otherwise be fatal (such as system errors), so they are necessary.
 - discuss programming examples:
 - discuss use of <<stdlib-result,`Result` module>>, with examples
 - discuss use of <<stdlib-option,`Option` module>>, with examples
 - discuss use of <<error-type, `Error` type>>; exceptions versus traps (is there a difference?)


