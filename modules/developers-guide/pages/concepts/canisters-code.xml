<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Canisters and code</title>
<date>2021-08-05</date>
</info>
<simpara>One of the most important principles to keep in mind is that the Internet Computer is primarily a distributed and decentralized platform for running software.</simpara>
<simpara>When you write source code for an application that runs on the Internet Computer, you compile the source code into a  <emphasis role="strong">WebAssembly module</emphasis>.
When you deploy the WebAssembly module that contains your program on an Internet Computer replica, the program is executed inside of a conceptual computational unit called a software <emphasis role="strong">canister</emphasis>.</simpara>
<simpara>Once deployed, end-users can interact with the software canister by accessing the entry point functions you have defined for that canister through a front-end client such as a browser.</simpara>
<section xml:id="canister-state">
<title>Canisters include both program and state</title>
<simpara>A software canister is similar to a container in that both are deployed as a software unit that contains compiled code and dependencies for an application or service.</simpara>
<simpara>Containerization allows for applications to be decoupled from the environment, allowing for easy and reliable deployment.
The canister differs from a container, however, in that it also stores information about the current software <emphasis role="strong">state</emphasis> with a record of preceding events and user interactions.</simpara>
<simpara>While a containerized application might include information about the state of the environment in which the application runs, a software canister is able to persist a record of state changes that resulted from an application’s functions being used.</simpara>
</section>
<section xml:id="query-update">
<title>Query and update methods</title>
<simpara>This concept of a canister consisting of both program and state is an important one because when a canister function is invoked by sending a message to one of its entry points, there are only two types of calls: non-committing <emphasis role="strong">query calls</emphasis> and committing <emphasis role="strong">update calls</emphasis>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="67.1049*"/>
<colspec colname="col_2" colwidth="357.895*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Key points to remember</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query calls</simpara></entry>
<entry align="left" valign="top"><simpara>Allow the user to query the current state of a canister or call a function that operates on the canister’s state <emphasis role="strong">without changing it</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Are synchronous and answered immediately.</simpara>
</listitem>
<listitem>
<simpara>Can be made to any node that holds the canister and do not require consensus to verify the result.
There is an inherent tradeoff between security and performance because the reply from a single node might be untrustworthy or inaccurate.</simpara>
</listitem>
<listitem>
<simpara>Do not allow changes to the state of the canister to be persisted. Essentially, programs use query calls to perform read-only operations.</simpara>
</listitem>
<listitem>
<simpara>Do not allow the called canister to invoke functions exposed by other canisters as inter-canister calls. (Note that this restriction is temporary and that canisters will be able to invoke functions exposed by other canisters when processing query calls in the future.)</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Update calls</simpara></entry>
<entry align="left" valign="top"><simpara>Allow the user to change the state of the canister and have <emphasis role="strong">changes persisted</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Are answered asynchronously.</simpara>
</listitem>
<listitem>
<simpara>Must pass through consensus to return the result.
Because consensus is required, changing the state of a canister can take time. Therefore, update calls use the actor-based programming model (with state isolation) to allow concurrent and asynchronous processing.
There is an inherent tradeoff between security and performance because two-thirds of the replicas in a subnet must agree on the result.</simpara>
</listitem>
<listitem>
<simpara>The called canister can invoke functions exposed by other canisters</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As a developer, it is important to recognize this relationship between the calls that query the canister and the calls that change the canister state.
In particular, you should keep in mind the inherent tradeoff between security and performance.</simpara>
</section>
<section xml:id="dev-motoko-intro">
<title>How to develop applications for the Internet Computer</title>
<simpara>For programmers and software developers, the {platform} provides unique capabilities and opportunities within a framework that simplifies how you can design, build, and deploy applications.
A key part of this framework is a new, general purpose programming language, Motoko.
Motoko is a programming language that has been specifically designed to take full advantage of the unique features that the Internet Computer provides, including:</simpara>
<itemizedlist>
<listitem>
<simpara>The ability to define programs directly using <literal>actor</literal> objects and classes.</simpara>
</listitem>
<listitem>
<simpara>The use of <literal>async</literal> and <literal>await</literal> syntax to enable programming asynchronous messaging as if it was synchronous processing.</simpara>
</listitem>
<listitem>
<simpara>Automatic support for message serialization and deserialization.</simpara>
</listitem>
<listitem>
<simpara>The ability to leverage orthogonal persistence using data structures without external databases or storage volumes.</simpara>
</listitem>
</itemizedlist>
<simpara>As a modern, high-level programming language, Motoko provides some key features of its own, including:</simpara>
<itemizedlist>
<listitem>
<simpara>Support for big integer operations and overflow protection.</simpara>
</listitem>
<listitem>
<simpara>A sound type system that statically checks each program to ensure it can execute without type errors on all possible inputs.</simpara>
</listitem>
<listitem>
<simpara>Support for function abstractions, user-defined type definitions, and user-defined actors.</simpara>
</listitem>
</itemizedlist>
<simpara>For more detailed information about the Motoko programming language itself, including syntactical conventions and supported features, see the <link xl:href="../../language-guide/motoko.xml"><emphasis>Motoko Programming Language Guide</emphasis></link>.</simpara>
<simpara>The following diagram provides a simplified drill-down view of the development environment as part of the Internet Computer ecosystem.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="SDK-protocol-network.svg"/>
</imageobject>
<textobject><phrase>Your development environment as part of the Internet Computer ecosystem</phrase></textobject>
</inlinemediaobject></simpara>
</section>
<section xml:id="actor-intro">
<title>Canisters, actors, and the code you produce</title>
<simpara>One of the most important principles to keep in mind when preparing to write programs using the Motoko programming language is that Motoko uses an <emphasis>actor-based</emphasis> programming model.</simpara>
<simpara>An <emphasis>actor</emphasis> is a special kind of object that processes messages in an isolated state, enabling messages to be handled remotely and asynchronously.
Many key features of the {platform} depend on this type of secure and efficient asynchronous message handling.</simpara>
<simpara>In general, each software canister includes the compiled code for one actor object.
Each canister also includes some additional information such as interface descriptions or front-end assets.
You can create projects that include multiple canisters, but each canister can only include one actor.</simpara>
</section>
<section xml:id="wasm-intro">
<title>Why your code is compiled into WebAssembly</title>
<simpara>When you compile Motoko code, the result is a WebAssembly module.
WebAssembly is a low-level computer instruction format that is portable and abstracts program execution cleanly over most modern computer hardware.
It is broadly supported for programs that run on the internet and a natural fit for deploying applications that are intended to run on the {platform}.</simpara>
<simpara>With Motoko, developers can compile to portable WebAssembly while still delivering secure applications using a simple and high-level language.</simpara>
<simpara>The Motoko language offers many of the features that are common to other higher-level modern languages—like type safety and pattern-matching.
In addition, Motoko provides built-in support for defining messaging services using actors in a way that is especially well-suited to the {platform} and is easy to learn whether you are a new or experienced programmer.</simpara>
<simpara>This guide provides an introduction to the basic features of the Motoko programming language in the context of writing programs using the SDK.
For more detailed information about the Motoko programming language itself, see the <link xl:href="../../language-guide/motoko.xml"><emphasis>Motoko Programming Language Guide</emphasis></link>.</simpara>
</section>
<section xml:id="auth-intro">
<title>Identities and authentication</title>
<simpara>One of the main differences between a user-initiated canister operation and a canister-to-canister operation is that canisters have an explicitly registered identity on the [IC].</simpara>
<simpara>There is no central registry for user principals.
Instead, user identifiers are associated specifically with the canisters each user accesses through one or more public-private key pairs.
The user’s private key is used to sign messages, which are sent along with their public key to a canister.
The [IC] authenticates the user and passes the principal to the canister for the authorization of their operation.</simpara>
<simpara>At a high level, first-time users generate an unsigned key pair and derive their principal identifier from the public key during their first interaction with the Internet Computer.
Returning users are authenticated using the private key (or keys) that have been stored securely by the user agent.
Users with access to multiple canisters can manage the keys and devices used for authentication associated with each canister.</simpara>
<simpara>A single user can have multiple public-private key pairs for accessing canisters from different devices—such as browsers running on different computers, mobile phones, or tablets—but these derived keys all map to a primary identifier.</simpara>
</section>
<section xml:id="resource-intro">
<title>Resource consumption and cycles</title>
<simpara>In general, all canisters consume resources in the form of CPU cycles for execution, bandwidth for routing messages, and memory for persisted data.
Canisters maintain an account balance of <emphasis role="strong">cycles</emphasis> to pay for the cost of communication, computation, and storage that their applications consume.</simpara>
<simpara>Cycles are intended to reflect the real cost of operations including physical hardware, rack space, energy, storage devices, and bandwidth in a stable or deflationary way so that the cost of program execution remains the same or decreases with operational efficiency.</simpara>
<itemizedlist>
<listitem>
<simpara>Programs must be able to pay for complete execution (all or nothing), but the cost associated with a unit of cycles will make efficient programs cost-effective.</simpara>
</listitem>
<listitem>
<simpara>By setting limits on how many cycles a canister can consume, the platform can prevent malicious code from draining resources.</simpara>
</listitem>
</itemizedlist>
<simpara>The relative stability of operational costs makes it easier to predict the cycles required to process, for example, a million messages.</simpara>
<simpara>The cycles available for program execution are held in a <emphasis role="strong">wallet canister</emphasis>. For local deployment, wallet canisters are automatically created and issued cycles. To deploy your application on the Internet Computer running on external nodes and subnets, however, you&#8217;ll need a principal with a cycles wallet to manage canister operations.</simpara>
</section>
<section xml:id="_want_to_learn_more">
<title>Want to learn more?</title>
<simpara>If you are looking for more information about canisters, check out the following related resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.youtube.com/watch?v=LKpGuBOXxtQ">Introducing Canisters — An Evolution of Smart Contracts (video)</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.youtube.com/watch?v=60uHQfoA8Dk">What is the DFINITY Canister SDK? (video)</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.youtube.com/watch?v=yqIoiyuGYNA">Deploying your first application (video)</link></simpara>
</listitem>
</itemizedlist>
</section>
</article>