= Sharing data and behavior

Recall that in {proglang}, mutable state is always private to an actor.

However, two actors can share message data, and those messages can
refer to actors, including themselves and one another.  Additionally,
messages may refer to individual functions, if those functions are `shared`.

Through these mechanisms, two actors can coordinate their behavior
through asynchronous message passing.

== Publisher-subscriber pattern with actors

To give a simple example, we focus on variations of the link:https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern["publisher-subscriber" pattern],
wherein a "publisher" actor records a list of "subscriber" actors to
notify when something notable occurs in the publisher's state (e.g., a
new "publication" is available).

Below, we use two actors in {proglang} to build variations of the
publisher-subscriber relationship between the actors.

For a complete working project,
see the link:https://github.com/dfinity/examples/tree/master/motoko/pubsub[pubsub example].

Below, we introduce the ideas gradually, showing the most salient pieces in code below.
See the link:https://github.com/dfinity/examples[`examples` repository] for working code.

=== A basic version

We begin the most basic version of the pattern by defining a type of
`Subscriber` actor type, which gives a common interface for the two
actors:

[source,motoko]
----
public type Subscriber = actor {
  notify : () -> ()
};
----

1. The `Publisher` uses this type to define a data structure to store its
subscribers as data.
2. Each `Subscriber` actor exposes an update function
`notify`, as in the `Subscriber` actor type signature above.  Recall that
subtyping permits the subscriber actor to also have additional methods not
listed in this type.

For simplicity, we assume a very simple type for `notify` above.  In
general, this `notify` function would accept relevant notification
data and perhaps return some new status of the subscriber to the
publisher, e.g., changing its subscription settings based on the
notification data.

For simplicity here, we do not consider such data, and let the
subscriber perform further queries of the publisher, if need be
(perhaps less efficient than a more custom protocol).


=== Publisher side

The publisher side of the code stores an array of subscribers, where
we assume (for simplicity) that each subscriber only subscribes
themselves once, via `subscribe`.

[source,motoko]
----
actor Publisher {
    var subscribers: [Subscriber] = [];

    public func subscribe(subscriber: Subscriber) {
        subscribers := Array.append<Subscriber>(subscribers, [subscriber]);
    };

    public func publish(counter: Counter) {
        for (subscriber in subscribers.vals()) {
          subscriber.notify();
        };
    };
};
----

Later, when some unspecified external agent invokes `publish`, all of
the subscribers receive the `notify` message, as in the `Subscriber`
type given above.

=== Subscriber side

In the simplest case, the subscriber side has three methods:
1. initially, subscribe to notifications from the publisher (`init`),
2. be notified as one of the subscribed actors (`notify`, as in the `Subscriber` type given above), and
1. permit queries to the accumulated state, in this case just a counter of notifications (`get`).

The code below implements each of these:

[source,motoko]
----
import Publisher "canister:pub";

actor Subscriber {
    var count: Nat = 0;
    public func init() {
        Publisher.subscribe(Subscriber);
    };
    public func notify() {
        count += 1;
    };
    public func get() : async Nat {
        count
    };
}
----

The actor assumes, but does not enforce, that its `init` function is
only ever called once.

If called more than once, the actor will subscribe itself multiple
times, and will receive multiple (duplicate) notifications from the
publisher.  This fragility is the consequence of the basic
publiisher-subscriber design we show above.  With more care, a more
advanced publisher actor could check for duplicate subscriber actors
and ignore them, for instance.

== Sharing functions among actors

In {proglang}, a `shared` actor function can be sent in a message to
another actor, and then later called by that actor, or another one.

The code shown above has been simplified for illustrative purposes.
The full version offers additional features to the
publisher-subscriber relationship, and uses shared functions to make
this relationship more flexible.

For instance, the notification function is _always_ designated as
`notify`.  A more flexible design would only fix the type of `notify`,
and permit the subscriber to choose any of its `shared` functions,
specified in a `subscribe` message in place of (just) the actor that
is subscribing.

See the link:https://github.com/dfinity/examples/tree/master/motoko/pubsub[the full example]
for details.

In particular, suppose that the subscriber wants to
avoid being locked into a certain naming scheme for its interface.
What really matters is that the publisher can call _some_ function
that the subscriber chooses.

=== The keyword `shared`

To permit this flexibility, an actor needs to share a single
_function_ that permits remote invocation from another actor, not
merely a reference to itself.

The ability to share a function requires that it be pre-designated as
`shared`, and the type system enforces that these functions follow
certain rules around the types of data that these functions accept,
return and over which their closures close.

We omit this keyword for actor methods since implicitly, _all public
functions of every actor are `shared`_, whether marked explicitly
or not.

More generally, a `shared` function is one that is _either_ part of
the public interface of an actor, _or_ it is not mentioned in the
public interface, but it does not close over the actor's mutable
state, and it adheres to the same argument and return-type typing
restrictions as a public actor function (e.g., no mutable data in
the arguments or results).

Using the `shared` type, we can extend the example above to be more
flexible:

[source,motoko]
----
type SubscribeMessage = { callback: shared () -> (); };
----

This type differs from the original, in that it describes _a message_
record type with a single field called `callback`, and the original type
first shown above describes _an actor_ type with a single method called
`notify`:

[source,motoko]
----
type Subscriber = actor { notify : () -> () };
-----

Notably, the `actor` keyword means that this latter type is not an
ordinary record with fields, but rather, an actor with at least one
method, which _must_ be called `notify`.

By using the `SubscribeMessage` type instead, the `Subscriber` actor
can choose another name for their `notify` method:

[source,motoko]
----
actor Subscriber {
    var count: Nat = 0;
    public func init() {
        Publisher.subscribe({callback = incr;});
    };
    public func incr() {
        count += 1;
    };
    public query func get(): async Nat {
        count
    };
};
----

Compared to the original version, the only (two) lines that change are
those that rename `notify` to `incr`, and form the new
`subscribe` message payload, via the expression `{callback = incr}`.

Likewise, we can update the publisher to have a matching interface:

[source,motoko]
----
type SubscribeMessage = { callback: shared () -> (); };
actor Publisher {
    var subs: [SubscribeMessage] = [];
    public func subscribe(sub: SubscribeMessage) {
         subs := Array.append<SubscribeMessage>(subs, [sub]);
    };
    public func publish() {
        for (sub in subs.vals()) {
            subscriber.callback();
         };
    };
};
----
