<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Develop using different languages</title>
<date>2021-08-05</date>
</info>
<simpara>Most of the examples in this guide use {proglang}—the programming language specifically designed to work with the {IC}.
Potentially, however, you can write programs in any language that compiles to WebAssembly to deploy applications that run on the {IC}.
This section provides some high-level guidance for writing programs in different languages and how to deploy them on the {IC}.</simpara>
<section xml:id="_using_rust">
<title>Using Rust</title>
<simpara>You can create Rust projects to run on the {IC} by using Cargo and compiling your program to use WebAssembly as the target output.</simpara>
<simpara>This section provides a summary of the key steps involved in deploying a Rust program as a smart contract canister on the {IC}.
You should note, however, that the steps described here only illustrate one approach.
Other implementation approaches are also possible.</simpara>
<simpara>Note that the <link xl:href="https://github.com/dfinity/cdk-rs">Rust canister development kit (Rust CDK)</link> for provides some shortcuts to make it easier to write functions as query and update calls and includes several <link xl:href="https://github.com/dfinity/cdk-rs/tree/next/examples">examples</link> to get you started building Rust-based projects, but you can also develop applications for the {IC} without using the Rust CDK.</simpara>
<section xml:id="_create_a_project">
<title>Create a project</title>
<simpara>Because most Rust programmers use Cargo to handle build and package management tasks—such as downloading and compiling the libraries your program depends on—your first step is to create a new Rust project using the Cargo command-line interface.</simpara>
<simpara>Alternatively, you could create a new project using {sdk-long-name} instead of Cargo, but creating a project using Cargo represents the typical workflow for creating Rust projects.</simpara>
<simpara>To create a new Rust project:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a terminal shell on your local computer, if you don’t already
have one open.</simpara>
</listitem>
<listitem>
<simpara>Verify that you have Cargo installed by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cargo --version</programlisting>
</listitem>
<listitem>
<simpara>Change to the folder you are using for your {IC} or Rust sample projects.</simpara>
</listitem>
<listitem>
<simpara>Create a new project by running a command similar to the following:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cargo new my_rust_program</programlisting>
<simpara>This command creates a new <literal>my_rust_program</literal> directory with a default <literal>Cargo.toml</literal> file and a <literal>src</literal> directory with a default <literal>main.rs</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Change to your project directory by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cd my_rust_program</programlisting>
<simpara>If you list the contents of this directory, you&#8217;ll see that it only contains the <literal>Cargo.toml</literal> file and <literal>src</literal> directory.
To compile this project to run on the {IC}, you&#8217;ll need some additional files.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_modify_the_cargo_configuration_file">
<title>Modify the Cargo configuration file</title>
<simpara>The <literal>Cargo.toml</literal> file provides a <emphasis role="strong">manifest</emphasis> for each Rust package.
The manifest contains sections that specify configuration details for the package.
To prepare the Rust project to run on the {IC}, we&#8217;ll copy the default <literal>Cargo.toml</literal> file then modify some of the configuration details for the project.</simpara>
<simpara>To modify the <literal>Cargo.toml</literal> file:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check that you are in the root directory for your project by running the <literal>pwd</literal> command, if necessary.</simpara>
</listitem>
<listitem>
<simpara>Copy the default <literal>Cargo.toml</literal> file to the <literal>src</literal> directory by running the following command:</simpara>
<programlisting language="toml" linenumbering="unnumbered">cp Cargo.toml src/Cargo.toml</programlisting>
<simpara>Projects that run on the {IC} typically use one project-level <literal>Cargo.toml</literal> file to set up a workspace for the canister members of the project and a second <literal>Cargo.toml</literal> file in the source code directory to configure settings for each canister.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>Cargo.toml</literal> file that is the root directory of your project in a text editor.</simpara>
<simpara>By default, the file contains the <literal>[package]</literal> and the <literal>[dependencies]</literal> sections.</simpara>
</listitem>
<listitem>
<simpara>Replace the <literal>[package]</literal> section with a <literal>[workspace]</literal> section similar to the following:</simpara>
<programlisting language="toml" linenumbering="unnumbered">[workspace]
members = [
    "src/my_rust_program",
]</programlisting>
<simpara>For information about the <literal>[workspace]</literal> section and <literal>[workspace]</literal> keys, see <link xl:href="https://doc.rust-lang.org/cargo/reference/workspaces.html">Workspaces</link>.
For information about the other sections and keys you can configure in the <literal>Cargo.toml</literal> file, see <link xl:href="https://doc.rust-lang.org/cargo/reference/manifest.html">The Manifest Format</link>.</simpara>
</listitem>
<listitem>
<simpara>Remove the <literal>[dependencies]</literal> section.</simpara>
</listitem>
<listitem>
<simpara>Save your changes and close the file to continue.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>src/Cargo.toml</literal> file in a text editor.</simpara>
</listitem>
<listitem>
<simpara>Add a <literal>[lib]</literal> section with the path to the main source code similar to the following:</simpara>
<programlisting language="toml" linenumbering="unnumbered">[lib]
path = "main.rs"</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>[dependencies]</literal> section with any package dependencies.</simpara>
</listitem>
<listitem>
<simpara>Save your changes and close the file to continue.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_add_a_canister_configuration_file">
<title>Add a canister configuration file</title>
<simpara>When you create a new project using the {sdk-short-name}, the <literal>dfx new</literal> command automatically adds a default <literal>dfx.json</literal> configuration file to the project directory.
Because we created the Rust project using Cargo, you need to manually create this file in your project directory.</simpara>
<simpara>To add the <literal>dfx.json</literal> configuration file:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check that you are still in your project directory by running the <literal>pwd</literal> command, if necessary.</simpara>
</listitem>
<listitem>
<simpara>Create a new <literal>dfx.json</literal> configuration file in the root directory for your project.</simpara>
</listitem>
<listitem>
<simpara>Open the `dfx.json`file in a text editor.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>version</literal> and <literal>canisters</literal> keys with settings similar to the following to the <literal>dfx.json</literal> file:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "version": 1,
  "canisters": {
    "my_rust_program": {
      "type": "custom",
      "candid": "src/my_rust_program.did",
      "wasm": "target/wasm32-unknown-unknown/debug/my_rust_program.wasm",
      "build": "cargo build --target wasm32-unknown-unknown --package my_rust_program"
    }
  }
}</programlisting>
<simpara>Let&#8217;s take a closer look at these settings.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>version</literal> setting is used to identify the version of the software used to create the project.</simpara>
</listitem>
<listitem>
<simpara>The <literal>canisters</literal> section specifies the name of the project&#8217;s canisters.
In this case, there&#8217;s only one canister and it is named <literal>my_rust_program</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>type</literal> key is set to <literal>custom</literal> because this canister is not one of the currently recognized (<literal>motoko</literal> or <literal>assets</literal>) canister types.</simpara>
</listitem>
<listitem>
<simpara>The <literal>candid</literal> key specifies the name and location of the Candid interface description file to use for this project.</simpara>
</listitem>
<listitem>
<simpara>The <literal>wasm</literal> key specifies the path to the WebAssembly file generated by the <literal>cargo build</literal> command.</simpara>
</listitem>
<listitem>
<simpara>The <literal>build</literal> key specifies the <literal>cargo</literal> command used to compile the output.</simpara>
</listitem>
</itemizedlist>
<simpara>These are the minimum settings required.
As you build more complex programs, you might need to include additional configuration details in the <literal>Cargo.toml</literal> file, the <literal>dfx.json</literal> file, or both files.</simpara>
</listitem>
<listitem>
<simpara>Save your changes and close the file to continue.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_create_a_candid_interface_description_file">
<title>Create a Candid interface description file</title>
<simpara>In addition to the <literal>dfx.json</literal> configuration file, you need to have a Candid interface description file—for example, <literal>my_rust_program.did</literal>—to map your program&#8217;s input parameters and return value formats to their language-agnostic representation in Candid.</simpara>
<simpara>To add the Candid interface description file:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check that you are still in your project directory by running the <literal>pwd</literal> command, if necessary.</simpara>
</listitem>
<listitem>
<simpara>Create a new Candid interface description file—for example, <literal>my_rust_program.did</literal>—in the <literal>src</literal> directory for your project.</simpara>
</listitem>
<listitem>
<simpara>Open the Candid interface description file in a text editor and add a description for each function the program defines.</simpara>
<simpara>For example, if the <literal>my_rust_program</literal> is a simple program that increments a counter using the <literal>increment</literal>, <literal>read</literal>, and <literal>write</literal> functions, the <literal>my_rust_program.did</literal> file might look like this:</simpara>
<programlisting language="candid" linenumbering="unnumbered">service : {
  "increment": () -&gt; ();
  "read": () -&gt; (nat) query;
  "write": (nat) -&gt; ();
}</programlisting>
</listitem>
<listitem>
<simpara>Save your changes and close the file to continue.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_modify_the_default_program">
<title>Modify the default program</title>
<simpara>When you create a new project, your project <literal>src</literal> directory includes a template <literal>main.rs</literal> file with the "Hello, World!" program.</simpara>
<simpara>To modify the template source code:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open the template <literal>src/main.rs</literal> file in a text editor and delete the existing content.</simpara>
</listitem>
<listitem>
<simpara>Write the program you want to deploy on the {IC}.</simpara>
<simpara>As you write your program, keep in mind that there are two types of calls—update calls and query calls—and that update functions use asynchronous messaging.</simpara>
</listitem>
<listitem>
<simpara>Save your changes and close the <literal>main.rs</literal> file.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_connect_to_a_network_and_deploy">
<title>Connect to a network and deploy</title>
<simpara>Before you can deploy and test your program, you need to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Connect to the {IC} network either running locally in your development environment or running remotely on a subnet that you can access.</simpara>
</listitem>
<listitem>
<simpara>Register a network-specific identifier for the application</simpara>
</listitem>
<listitem>
<simpara>Compile the program with a target output of WebAssembly.</simpara>
</listitem>
</itemizedlist>
<simpara>Because you configured the custom <literal>dfx.json</literal> file with a <literal>cargo build</literal> command that compiles to WebAssembly, you can use the <literal>dfx</literal> command-line interface and standard work flow to perform all of the remaining steps.</simpara>
<simpara>To build and deploy the program locally:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check that you are still in your project directory by running the <literal>pwd</literal> command, if necessary.</simpara>
</listitem>
<listitem>
<simpara>Open a new terminal window or tab on your local computer and navigate to your project directory.</simpara>
<simpara>For example, you can do either of the following if running Terminal on macOS:</simpara>
<itemizedlist>
<listitem>
<simpara>Click <emphasis role="strong">Shell</emphasis>, then select <emphasis role="strong">New Tab</emphasis> to open a new terminal in your current working directory.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Shell</emphasis> and select <emphasis role="strong">New Window</emphasis>, then run <literal>cd ~/ic-projects/location_hello</literal> in the new terminal if your <literal>location_hello</literal> project is in the <literal>ic-projects</literal> working folder.</simpara>
</listitem>
</itemizedlist>
<simpara>You should now have two terminals open with your project directory as your current working directory**.</simpara>
</listitem>
<listitem>
<simpara>Start the {IC} network on your local computer by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx start</programlisting>
<simpara>Depending on your platform and local security settings, you might see a warning displayed.
If you are prompted to allow or deny incoming network connections, click <emphasis role="strong">Allow</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Leave the terminal that displays network operations open and switch your focus to your original terminal where you created your project.</simpara>
</listitem>
<listitem>
<simpara>Register a unique canister identifier for the application by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx canister create --all</programlisting>
</listitem>
<listitem>
<simpara>Build the program by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx build</programlisting>
</listitem>
<listitem>
<simpara>Deploy the program on the local network by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx canister install --all</programlisting>
</listitem>
<listitem>
<simpara>Test functions in the program from the command-line or in a browser.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_using_c">
<title>Using C</title>
<simpara>Because the {IC} supports applications compiled to standard WebAssembly modules, you can use standard compilers and toolchains to build applications in languages such as  C, C++, Objective-C, and Objective-C++ programming languages and the <literal>Clang</literal> compiler.</simpara>
<simpara>To illustrate how to migrate programs written in C to run on the {IC}, let’s look at the simple <literal>reverse.c</literal> program in the <link xl:href="https://github.com/dfinity/examples/tree/master/c">examples</link> repository.
The <literal>reverse.c</literal> program contains one function—named <literal>go</literal>—that reverses a string in place.</simpara>
<section xml:id="_set_up_the_development_environment">
<title>Set up the development environment</title>
<simpara>To compile the <literal>reverse.c</literal> program into WebAssembly, you need to have the <literal>clang</literal> compiler and standard libraries installed.
You can check whether you have <literal>clang</literal> installed on your local computer by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">clang --version</programlisting>
<simpara>If <literal>clang</literal> is installed, the command displays information similar to the following:</simpara>
<literallayout class="monospaced">clang version 10.0.0
Target: x86_64-apple-darwin19.5.0
Thread model: posix
InstalledDir: /usr/local/opt/llvm/bin</literallayout>
<simpara>If the command doesn’t return version information, install <literal>clang</literal> before continuing.
The steps to install <literal>clang</literal> vary depending on the operating system you are using.
On Debian Linux, for example, run the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">sudo apt-get install clang lld gcc-multilib</programlisting>
<simpara>On macOS, you can install <literal>clang</literal> by installing the Developer Command-Line Tools or by installing LLVM using Homebrew.
For example, if <literal>clang</literal> is not installed, run the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">brew install llvm</programlisting>
</section>
<section xml:id="_compile_the_program_into_webassembly">
<title>Compile the program into WebAssembly</title>
<simpara>You can compile a C program to run as a WebAssembly module by first compiling using <literal>clang</literal>, then linking using <literal>wasm-ld</literal>.
Depending on the operating system and version of <literal>clang</literal> you are using, you might use a different version of the WebAssembly linker, such as <literal>wasm-ld</literal> on macOS or <literal>wasm-ld-8</literal> on Debian.</simpara>
<simpara>To compile to WebAssembly on macOS:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Compile the program by running the following clang command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">clang --target=wasm32 -c -O3 reverse.c</programlisting>
</listitem>
<listitem>
<simpara>Run the linker to create the WebAssembly module by running the following <literal>wasm-ld</literal> command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">wasm-ld --no-entry --export-dynamic --allow-undefined reverse.o -o reverse.wasm</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_create_a_minimal_configuration_file">
<title>Create a minimal configuration file</title>
<simpara>Next, you need to prepare a simple configuration file that identifies the <literal>reverse</literal> program binary as a package that can be installed on the {IC} and a <literal>build</literal> directory so that you can use the <literal>dfx</literal> command-line interface to install and run the package as a canister.</simpara>
<simpara>To prepare a configuration file and build directory:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a <literal>dfx.json</literal> file with a canisters key by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">echo '{"canisters":{"reverse":{"main":"reverse"}}}' &gt; dfx.json</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>build</literal> directory for the program by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir build</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>reverse</literal> directory for the program by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir build/reverse</programlisting>
</listitem>
<listitem>
<simpara>Copy the WebAssembly modules to the new <literal>build/reverse</literal> directory by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cp reverse.wasm build/reverse/</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_create_a_minimal_interface_description_file">
<title>Create a minimal interface description file</title>
<simpara>In a standard development workflow, running the <literal>dfx build</literal> command creates several files in the <literal>canisters</literal> output directory, including one or more Candid interface description (<literal>.did</literal>) files that handle type matching for the data types associated with a program’s functions.</simpara>
<simpara>For details about the syntax to use for different data types, see the <link xl:href="../candid-guide/candid-intro.xml"><emphasis>Candid Guide</emphasis></link> and <link xl:href="https://github.com/dfinity/candid/tree/master/spec">Candid specification</link>.</simpara>
<simpara>To create a Candid interface description file for this program:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a terminal in the <literal>build</literal> directory you created for the <literal>reverse.c</literal> program source</simpara>
</listitem>
<listitem>
<simpara>Create a new text file named <literal>reverse.did</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add a description of the <literal>go</literal> function.</simpara>
<simpara>For example:</simpara>
<screen role="bash" linenumbering="unnumbered">service : {
  "go": (text) -&gt; (text);
}</screen>
</listitem>
<listitem>
<simpara>Save your changes and close the file to continue.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_deploy_and_test_the_program">
<title>Deploy and test the program</title>
<simpara>Before you can deploy and test your program, you need to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Connect to the {IC} network either running locally in your development environment or running remotely on a subnet that you can access.</simpara>
</listitem>
<listitem>
<simpara>Register a network-specific identifier for the application.</simpara>
</listitem>
</itemizedlist>
<simpara>To deploy and test the application locally:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a new terminal window or tab on your local computer.</simpara>
<simpara>For example, if running Terminal on macOS,click <emphasis role="strong">Shell</emphasis>, then select <emphasis role="strong">New Tab</emphasis> to open a new terminal in your current working directory.</simpara>
</listitem>
<listitem>
<simpara>Start the {IC} network on your local computer in your second terminal by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx start</programlisting>
</listitem>
<listitem>
<simpara>Register a unique canister identifier for the <literal>reverse</literal> application by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx canister create --all</programlisting>
</listitem>
<listitem>
<simpara>Deploy the default program on the local network by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx canister install --all</programlisting>
</listitem>
<listitem>
<simpara>Call the <literal>go</literal> function in the program by running the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">dfx canister call reverse go reward
("drawer")</programlisting>
</listitem>
</orderedlist>
<simpara>You can find additional examples of C programs in the <link xl:href="https://github.com/dfinity/examples/tree/master/c">examples</link> repository.</simpara>
</section>
</section>
</article>